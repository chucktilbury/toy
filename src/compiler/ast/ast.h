/**
 * @file ./out/ast/ast.h
 *
 * This is generated by parser_template_generator. If you edit this file,
 * don't run the generator in this directory. Run it in a different one and
 * then merge the results using a tool like diff.
 *
 * @date Sat Jul 19 18:26:30 2025
 * @author Chuck Tilbury
 *
 */

#ifndef _AST_H_
#define _AST_H_

#include "tokens.h"
#include "pointer_list.h"

typedef enum {
    AST_ASSIGNMENT = 512,
    AST_BOOL_LITERAL = 513,
    AST_COMPOUND_NAME = 514,
    AST_COMPOUND_REFERENCE = 515,
    AST_COMPOUND_REFERENCE_ELEMENT = 516,
    AST_DATA_DECLARATION = 517,
    AST_DATA_DEFINITION = 518,
    AST_DICT_INIT = 519,
    AST_DO_CLAUSE = 520,
    AST_DSS_INITIALIZER = 521,
    AST_DSS_INITIALIZER_ITEM = 522,
    AST_ELSE_CLAUSE = 523,
    AST_EXIT_STATEMENT = 524,
    AST_EXPRESSION = 525,
    AST_EXPRESSION_LIST = 526,
    AST_FINAL_ELSE_CLAUSE = 527,
    AST_FOR_CLAUSE = 528,
    AST_FORMATTED_STRING = 529,
    AST_FUNCTION_BODY = 530,
    AST_FUNCTION_BODY_ELEMENT = 531,
    AST_FUNCTION_BODY_LIST = 532,
    AST_FUNCTION_BODY_PRELIST = 533,
    AST_FUNCTION_DEFINITION = 534,
    AST_FUNCTION_NAME = 535,
    AST_FUNCTION_PARAMETERS = 536,
    AST_FUNCTION_REFERENCE = 537,
    AST_IF_CLAUSE = 538,
    AST_IMPORT_STATEMENT = 539,
    AST_INITIALIZER = 540,
    AST_LIST_INIT = 541,
    AST_LIST_REFERENCE = 542,
    AST_LITERAL_TYPE_NAME = 543,
    AST_LOOP_BODY = 544,
    AST_LOOP_BODY_ELEMENT = 545,
    AST_LOOP_BODY_LIST = 546,
    AST_LOOP_BODY_PRELIST = 547,
    AST_PRIMARY_EXPRESSION = 548,
    AST_RETURN_STATEMENT = 549,
    AST_START_BLOCK = 550,
    AST_STRUCT_DEFINITION = 551,
    AST_STRUCT_INIT = 552,
    AST_TRANSLATION_UNIT = 553,
    AST_TRANSLATION_UNIT_ELEMENT = 554,
    AST_TYPE_NAME = 555,
    AST_WHILE_CLAUSE = 556
} ast_type_t;

typedef struct _ast_node_t_ {
    ast_type_t type;
    const char* fname;
    int line_no;
    int col_no;
} ast_node_t;

/*
 * assignment (
 *     compound_name TOK_EQUAL expression
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: compound_name
 *   terminal rule element: TOK_EQUAL
 *   non-terminal rule element: expression
 * end grouping_function (1000)
 *
 */
typedef struct _ast_assignment_t_ {
    ast_node_t node;
    struct _ast_compound_name_t_* compound_name;
    struct _ast_expression_t_* expression;
} ast_assignment_t;


/*
 * bool_literal (
 *     TOK_TRUE |
 *     TOK_FALSE
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     terminal rule element: TOK_TRUE
 *     terminal rule element: TOK_FALSE
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_bool_literal_t_ {
    ast_node_t node;
    token_t* tok;
} ast_bool_literal_t;


/*
 * compound_name (
 *     TOK_IDENTIFIER ( TOK_DOT TOK_IDENTIFIER ) *
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_IDENTIFIER
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_DOT
 *       terminal rule element: TOK_IDENTIFIER
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_compound_name_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_compound_name_t;


/*
 * compound_reference (
 *     compound_reference_element ( TOK_DOT compound_reference_element ) *
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: compound_reference_element
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_DOT
 *       non-terminal rule element: compound_reference_element
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_compound_reference_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_compound_reference_t;


/*
 * compound_reference_element (
 *     TOK_IDENTIFIER |
 *     function_reference |
 *     list_reference
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       terminal rule element: TOK_IDENTIFIER
 *       non-terminal rule element: function_reference
 *     end or_function (1200)
 *     non-terminal rule element: list_reference
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_compound_reference_element_t_ {
    ast_node_t node;
    token_t* IDENTIFIER;
    struct _ast_function_reference_t_* function_reference;
    struct _ast_list_reference_t_* list_reference;
} ast_compound_reference_element_t;


/*
 * data_declaration (
 *     type_name TOK_IDENTIFIER
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: type_name
 *   terminal rule element: TOK_IDENTIFIER
 * end grouping_function (1000)
 *
 */
typedef struct _ast_data_declaration_t_ {
    ast_node_t node;
    struct _ast_type_name_t_* type_name;
    token_t* IDENTIFIER;
} ast_data_declaration_t;


/*
 * data_definition (
 *     TOK_CONST ? data_declaration ( TOK_EQUAL initializer ) ?
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin zero_or_one_function (1100)
 *     terminal rule element: TOK_CONST
 *   end zero_or_one_function (1100)
 *   non-terminal rule element: data_declaration
 *   begin zero_or_one_function (1200)
 *     begin grouping_function (1300)
 *       terminal rule element: TOK_EQUAL
 *       non-terminal rule element: initializer
 *     end grouping_function (1300)
 *   end zero_or_one_function (1200)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_data_definition_t_ {
    ast_node_t node;
    bool is_const;
    struct _ast_data_declaration_t_* data_declaration;
    struct _ast_initializer_t_* initializer;
} ast_data_definition_t;


/*
 * dict_init (
 *     TOK_OSBRACE dss_initializer TOK_CSBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OSBRACE
 *   non-terminal rule element: dss_initializer
 *   terminal rule element: TOK_CSBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_dict_init_t_ {
    ast_node_t node;
    struct _ast_dss_initializer_t_* dss_initializer;
} ast_dict_init_t;


/*
 * do_clause (
 *     TOK_DO loop_body TOK_WHILE ( TOK_OPAREN expression ? TOK_CPAREN ) ?
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_DO
 *   non-terminal rule element: loop_body
 *   terminal rule element: TOK_WHILE
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       begin zero_or_one_function (1300)
 *         non-terminal rule element: expression
 *       end zero_or_one_function (1300)
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_do_clause_t_ {
    ast_node_t node;
    struct _ast_loop_body_t_* loop_body;
    struct _ast_expression_t_* expression;
} ast_do_clause_t;


/*
 * dss_initializer (
 *     dss_initializer_item ( TOK_COMMA dss_initializer_item ) *
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: dss_initializer_item
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_COMMA
 *       non-terminal rule element: dss_initializer_item
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_dss_initializer_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_dss_initializer_t;


/*
 * dss_initializer_item (
 *     TOK_STRING_LITERAL TOK_COLON expression
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_STRING_LITERAL
 *   terminal rule element: TOK_COLON
 *   non-terminal rule element: expression
 * end grouping_function (1000)
 *
 */
typedef struct _ast_dss_initializer_item_t_ {
    ast_node_t node;
    token_t* STRING_LITERAL;
    struct _ast_expression_t_* expression;
} ast_dss_initializer_item_t;


/*
 * else_clause (
 *     TOK_ELSE TOK_OPAREN expression TOK_CPAREN function_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_ELSE
 *   terminal rule element: TOK_OPAREN
 *   non-terminal rule element: expression
 *   terminal rule element: TOK_CPAREN
 *   non-terminal rule element: function_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_else_clause_t_ {
    ast_node_t node;
    struct _ast_expression_t_* expression;
    struct _ast_function_body_t_* function_body;
} ast_else_clause_t;


/*
 * exit_statement (
 *     TOK_EXIT TOK_OPAREN expression TOK_CPAREN
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_EXIT
 *   terminal rule element: TOK_OPAREN
 *   non-terminal rule element: expression
 *   terminal rule element: TOK_CPAREN
 * end grouping_function (1000)
 *
 */
typedef struct _ast_exit_statement_t_ {
    ast_node_t node;
    struct _ast_expression_t_* expression;
} ast_exit_statement_t;


/*
 * expression (
 *     expression TOK_STAR expression |
 *     expression TOK_SLASH expression |
 *     expression TOK_PERCENT expression |
 *     expression TOK_PLUS expression |
 *     expression TOK_MINUS expression |
 *     expression ( TOK_CPBRACE | TOK_GT ) expression |
 *     expression ( TOK_OPBRACE | TOK_LT ) expression |
 *     expression ( TOK_CPBRACE_EQUAL | TOK_GTE ) expression |
 *     expression ( TOK_OPBRACE_EQUAL | TOK_LTE ) expression |
 *     expression ( TOK_EQUAL_EQUAL | TOK_EQU ) expression |
 *     expression ( TOK_BANG_EQUAL | TOK_NEQU ) expression |
 *     expression ( TOK_AMP | TOK_AND ) expression |
 *     expression ( TOK_BAR | TOK_OR ) expression |
 *     expression TOK_CARET expression |
 *     ( TOK_BANG | TOK_NOT ) expression |
 *     TOK_MINUS expression |
 *     primary_expression
 * )
 *
 * Expressions are parsed with Dijkstra's shunting yard algorithm.
 */
typedef struct _ast_expression_t_ {
    ast_node_t node;
    // list of tokens in postfix format
    pointer_list_t* expr;
} ast_expression_t;


/*
 * expression_list (
 *     expression ( TOK_COMMA expression ) *
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: expression
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_COMMA
 *       non-terminal rule element: expression
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_expression_list_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_expression_list_t;


/*
 * final_else_clause (
 *     TOK_ELSE ( TOK_OPAREN TOK_CPAREN ) ? function_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_ELSE
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 *   non-terminal rule element: function_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_final_else_clause_t_ {
    ast_node_t node;
    struct _ast_function_body_t_* function_body;
} ast_final_else_clause_t;


/*
 * for_clause (
 *     TOK_FOR ( TOK_OPAREN ( literal_type_name ? TOK_IDENTIFIER TOK_IN ) ? expression TOK_CPAREN ) ? loop_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_FOR
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       begin zero_or_one_function (1300)
 *         begin grouping_function (1400)
 *           begin zero_or_one_function (1500)
 *             non-terminal rule element: literal_type_name
 *           end zero_or_one_function (1500)
 *           terminal rule element: TOK_IDENTIFIER
 *           terminal rule element: TOK_IN
 *         end grouping_function (1400)
 *       end zero_or_one_function (1300)
 *       non-terminal rule element: expression
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 *   non-terminal rule element: loop_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_for_clause_t_ {
    ast_node_t node;
    struct _ast_literal_type_name_t_* literal_type_name;
    token_t* IDENTIFIER;
    struct _ast_expression_t_* expression;
    struct _ast_loop_body_t_* loop_body;
} ast_for_clause_t;


/*
 * formatted_string (
 *     TOK_STRING_LITERAL ( TOK_OPAREN dss_initializer ? TOK_CPAREN ) ?
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_STRING_LITERAL
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       begin zero_or_one_function (1300)
 *         non-terminal rule element: dss_initializer
 *       end zero_or_one_function (1300)
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_formatted_string_t_ {
    ast_node_t node;
    token_t* STRING_LITERAL;
    struct _ast_dss_initializer_t_* dss_initializer;
} ast_formatted_string_t;


/*
 * function_body (
 *     TOK_OCBRACE function_body_list TOK_CCBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OCBRACE
 *   non-terminal rule element: function_body_list
 *   terminal rule element: TOK_CCBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_body_t_ {
    ast_node_t node;
    struct _ast_function_body_list_t_* function_body_list;
} ast_function_body_t;


/*
 * function_body_element (
 *     assignment |
 *     compound_reference |
 *     data_definition |
 *     struct_definition |
 *     if_clause |
 *     while_clause |
 *     do_clause |
 *     for_clause |
 *     return_statement |
 *     exit_statement |
 *     TOK_INLINE
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       begin or_function (1300)
 *         begin or_function (1400)
 *           begin or_function (1500)
 *             begin or_function (1600)
 *               begin or_function (1700)
 *                 begin or_function (1800)
 *                   begin or_function (1900)
 *                     begin or_function (2000)
 *                       non-terminal rule element: assignment
 *                       non-terminal rule element: compound_reference
 *                     end or_function (2000)
 *                     non-terminal rule element: data_definition
 *                   end or_function (1900)
 *                   non-terminal rule element: struct_definition
 *                 end or_function (1800)
 *                 non-terminal rule element: if_clause
 *               end or_function (1700)
 *               non-terminal rule element: while_clause
 *             end or_function (1600)
 *             non-terminal rule element: do_clause
 *           end or_function (1500)
 *           non-terminal rule element: for_clause
 *         end or_function (1400)
 *         non-terminal rule element: return_statement
 *       end or_function (1300)
 *       non-terminal rule element: exit_statement
 *     end or_function (1200)
 *     terminal rule element: TOK_INLINE
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_body_element_t_ {
    ast_node_t node;
    ast_node_t* nterm;
    token_t* INLINE;
} ast_function_body_element_t;


/*
 * function_body_list (
 *     function_body_prelist function_body_prelist *
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: function_body_prelist
 *   begin zero_or_more_function (1100)
 *     non-terminal rule element: function_body_prelist
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_body_list_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_function_body_list_t;


/*
 * function_body_prelist (
 *     function_body_element |
 *     function_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     non-terminal rule element: function_body_element
 *     non-terminal rule element: function_body
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_body_prelist_t_ {
    ast_node_t node;
    ast_node_t* nterm;
} ast_function_body_prelist_t;


/*
 * function_definition (
 *     function_name function_parameters function_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: function_name
 *   non-terminal rule element: function_parameters
 *   non-terminal rule element: function_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_definition_t_ {
    ast_node_t node;
    struct _ast_function_name_t_* function_name;
    struct _ast_function_parameters_t_* function_parameters;
    struct _ast_function_body_t_* function_body;
} ast_function_definition_t;


/*
 * function_name (
 *     ( type_name TOK_IDENTIFIER ) |
 *     ( TOK_NOTHING TOK_IDENTIFIER )
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin grouping_function (1200)
 *       non-terminal rule element: type_name
 *       terminal rule element: TOK_IDENTIFIER
 *     end grouping_function (1200)
 *     begin grouping_function (1300)
 *       terminal rule element: TOK_NOTHING
 *       terminal rule element: TOK_IDENTIFIER
 *     end grouping_function (1300)
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_name_t_ {
    ast_node_t node;
    struct _ast_type_name_t_* type_name;
    token_t* IDENTIFIER;
} ast_function_name_t;


/*
 * function_parameters (
 *     TOK_OPAREN ( data_declaration ( TOK_COMMA data_declaration ) * ) ? TOK_CPAREN
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OPAREN
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       non-terminal rule element: data_declaration
 *       begin zero_or_more_function (1300)
 *         begin grouping_function (1400)
 *           terminal rule element: TOK_COMMA
 *           non-terminal rule element: data_declaration
 *         end grouping_function (1400)
 *       end zero_or_more_function (1300)
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 *   terminal rule element: TOK_CPAREN
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_parameters_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_function_parameters_t;


/*
 * function_reference (
 *     TOK_IDENTIFIER TOK_OPAREN expression_list TOK_CPAREN
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_IDENTIFIER
 *   terminal rule element: TOK_OPAREN
 *   non-terminal rule element: expression_list
 *   terminal rule element: TOK_CPAREN
 * end grouping_function (1000)
 *
 */
typedef struct _ast_function_reference_t_ {
    ast_node_t node;
    struct _ast_expression_list_t_* expression_list;
} ast_function_reference_t;


/*
 * if_clause (
 *     TOK_IF TOK_OPAREN expression TOK_CPAREN function_body else_clause * final_else_clause ?
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_IF
 *   terminal rule element: TOK_OPAREN
 *   non-terminal rule element: expression
 *   terminal rule element: TOK_CPAREN
 *   non-terminal rule element: function_body
 *   begin zero_or_more_function (1100)
 *     non-terminal rule element: else_clause
 *   end zero_or_more_function (1100)
 *   begin zero_or_one_function (1200)
 *     non-terminal rule element: final_else_clause
 *   end zero_or_one_function (1200)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_if_clause_t_ {
    ast_node_t node;
    struct _ast_expression_t_* expression;
    struct _ast_function_body_t_* function_body;
    struct _ast_else_clause_t_* else_clause;
    struct _ast_final_else_clause_t_* final_else_clause;
} ast_if_clause_t;


/*
 * import_statement (
 *     TOK_IMPORT TOK_STRING_LITERAL
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_IMPORT
 *   terminal rule element: TOK_STRING_LITERAL
 * end grouping_function (1000)
 *
 * NOTE that this is handled at the parser level and the AST never traverses it.
 *
 */
typedef struct _ast_import_statement_t_ {
    ast_node_t node;
    token_t* STRING_LITERAL;
} ast_import_statement_t;


/*
 * initializer (
 *     expression |
 *     list_init |
 *     dict_init |
 *     struct_init
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       begin or_function (1300)
 *         non-terminal rule element: expression
 *         non-terminal rule element: list_init
 *       end or_function (1300)
 *       non-terminal rule element: dict_init
 *     end or_function (1200)
 *     non-terminal rule element: struct_init
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_initializer_t_ {
    ast_node_t node;
    ast_node_t* nterm;
} ast_initializer_t;


/*
 * list_init (
 *     TOK_OSBRACE expression ( TOK_COMMA expression ) * TOK_CSBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OSBRACE
 *   non-terminal rule element: expression
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_COMMA
 *       non-terminal rule element: expression
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 *   terminal rule element: TOK_CSBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_list_init_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_list_init_t;


/*
 * list_reference (
 *     TOK_IDENTIFIER TOK_OSBRACE expression TOK_CSBRACE ( TOK_OSBRACE expression TOK_CSBRACE ) *
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_IDENTIFIER
 *   terminal rule element: TOK_OSBRACE
 *   non-terminal rule element: expression
 *   terminal rule element: TOK_CSBRACE
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OSBRACE
 *       non-terminal rule element: expression
 *       terminal rule element: TOK_CSBRACE
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_list_reference_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_list_reference_t;


/*
 * literal_type_name (
 *     TOK_INT |
 *     TOK_FLOAT |
 *     TOK_STRING |
 *     TOK_LIST |
 *     TOK_DICT |
 *     TOK_BOOL
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       begin or_function (1300)
 *         begin or_function (1400)
 *           begin or_function (1500)
 *             terminal rule element: TOK_INT
 *             terminal rule element: TOK_FLOAT
 *           end or_function (1500)
 *           terminal rule element: TOK_STRING
 *         end or_function (1400)
 *         terminal rule element: TOK_LIST
 *       end or_function (1300)
 *       terminal rule element: TOK_DICT
 *     end or_function (1200)
 *     terminal rule element: TOK_BOOL
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_literal_type_name_t_ {
    ast_node_t node;
    token_t* tok;
} ast_literal_type_name_t;


/*
 * loop_body (
 *     TOK_OCBRACE loop_body_list TOK_CCBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OCBRACE
 *   non-terminal rule element: loop_body_list
 *   terminal rule element: TOK_CCBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_loop_body_t_ {
    ast_node_t node;
    struct _ast_loop_body_list_t_* loop_body_list;
} ast_loop_body_t;


/*
 * loop_body_element (
 *     function_body_element |
 *     TOK_CONTINUE |
 *     TOK_BREAK
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       non-terminal rule element: function_body_element
 *       terminal rule element: TOK_CONTINUE
 *     end or_function (1200)
 *     terminal rule element: TOK_BREAK
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_loop_body_element_t_ {
    ast_node_t node;
    struct _ast_function_body_element_t_* function_body_element;
    token_t* tok;
} ast_loop_body_element_t;


/*
 * loop_body_list (
 *     loop_body_prelist loop_body_prelist *
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: loop_body_prelist
 *   begin zero_or_more_function (1100)
 *     non-terminal rule element: loop_body_prelist
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_loop_body_list_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_loop_body_list_t;


/*
 * loop_body_prelist (
 *     loop_body_element |
 *     loop_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     non-terminal rule element: loop_body_element
 *     non-terminal rule element: loop_body
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_loop_body_prelist_t_ {
    ast_node_t node;
    ast_node_t* nterm;
} ast_loop_body_prelist_t;


/*
 * primary_expression (
 *     TOK_INT_LITERAL |
 *     TOK_FLOAT_LITERAL |
 *     formatted_string |
 *     bool_literal |
 *     ( TOK_OPAREN expression TOK_CPAREN ) |
 *     compound_reference
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       begin or_function (1300)
 *         begin or_function (1400)
 *           begin or_function (1500)
 *             terminal rule element: TOK_INT_LITERAL
 *             terminal rule element: TOK_FLOAT_LITERAL
 *           end or_function (1500)
 *           non-terminal rule element: formatted_string
 *         end or_function (1400)
 *         non-terminal rule element: bool_literal
 *       end or_function (1300)
 *       begin grouping_function (1600)
 *         terminal rule element: TOK_OPAREN
 *         non-terminal rule element: expression
 *         terminal rule element: TOK_CPAREN
 *       end grouping_function (1600)
 *     end or_function (1200)
 *     non-terminal rule element: compound_reference
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_primary_expression_t_ {
    ast_node_t node;
    token_t* token;
    ast_node_t* nterm;
} ast_primary_expression_t;


/*
 * return_statement (
 *     TOK_RETURN ( TOK_OPAREN expression ? TOK_CPAREN ) ?
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_RETURN
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       begin zero_or_one_function (1300)
 *         non-terminal rule element: expression
 *       end zero_or_one_function (1300)
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_return_statement_t_ {
    ast_node_t node;
    struct _ast_expression_t_* expression;
} ast_return_statement_t;


/*
 * start_block (
 *     TOK_START function_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_START
 *   non-terminal rule element: function_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_start_block_t_ {
    ast_node_t node;
    struct _ast_function_body_t_* function_body;
} ast_start_block_t;


/*
 * struct_definition (
 *     TOK_STRUCT TOK_IDENTIFIER TOK_OCBRACE data_declaration ( data_declaration ) * TOK_CCBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_STRUCT
 *   terminal rule element: TOK_IDENTIFIER
 *   terminal rule element: TOK_OCBRACE
 *   non-terminal rule element: data_declaration
 *   begin zero_or_more_function (1100)
 *     begin grouping_function (1200)
 *       non-terminal rule element: data_declaration
 *     end grouping_function (1200)
 *   end zero_or_more_function (1100)
 *   terminal rule element: TOK_CCBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_struct_definition_t_ {
    ast_node_t node;
    token_t* IDENTIFIER;
    pointer_list_t* list;
} ast_struct_definition_t;


/*
 * struct_init (
 *     TOK_OCBRACE dss_initializer TOK_CCBRACE
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_OCBRACE
 *   non-terminal rule element: dss_initializer
 *   terminal rule element: TOK_CCBRACE
 * end grouping_function (1000)
 *
 */
typedef struct _ast_struct_init_t_ {
    ast_node_t node;
    struct _ast_dss_initializer_t_* dss_initializer;
} ast_struct_init_t;


/*
 * translation_unit (
 *     translation_unit_element *
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin zero_or_more_function (1100)
 *     non-terminal rule element: translation_unit_element
 *   end zero_or_more_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_translation_unit_t_ {
    ast_node_t node;
    pointer_list_t* list;
} ast_translation_unit_t;


/*
 * translation_unit_element (
 *     import_statement |
 *     data_definition |
 *     function_definition |
 *     struct_definition start_block
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     begin or_function (1200)
 *       begin or_function (1300)
 *         non-terminal rule element: import_statement
 *         non-terminal rule element: data_definition
 *       end or_function (1300)
 *       non-terminal rule element: function_definition
 *     end or_function (1200)
 *     non-terminal rule element: struct_definition
 *   end or_function (1100)
 *   non-terminal rule element: start_block
 * end grouping_function (1000)
 *
 */
typedef struct _ast_translation_unit_element_t_ {
    ast_node_t node;
    ast_node_t* nterm;
} ast_translation_unit_element_t;


/*
 * type_name (
 *     literal_type_name |
 *     compound_name
 * )
 *
 *
 * begin grouping_function (1000)
 *   begin or_function (1100)
 *     non-terminal rule element: literal_type_name
 *     non-terminal rule element: compound_name
 *   end or_function (1100)
 * end grouping_function (1000)
 *
 */
typedef struct _ast_type_name_t_ {
    ast_node_t node;
    ast_node_t* nterm;
} ast_type_name_t;


/*
 * while_clause (
 *     TOK_WHILE ( TOK_OPAREN expression ? TOK_CPAREN ) ? loop_body
 * )
 *
 *
 * begin grouping_function (1000)
 *   terminal rule element: TOK_WHILE
 *   begin zero_or_one_function (1100)
 *     begin grouping_function (1200)
 *       terminal rule element: TOK_OPAREN
 *       begin zero_or_one_function (1300)
 *         non-terminal rule element: expression
 *       end zero_or_one_function (1300)
 *       terminal rule element: TOK_CPAREN
 *     end grouping_function (1200)
 *   end zero_or_one_function (1100)
 *   non-terminal rule element: loop_body
 * end grouping_function (1000)
 *
 */
typedef struct _ast_while_clause_t_ {
    ast_node_t node;
    struct _ast_expression_t_* expression;
    struct _ast_loop_body_t_* loop_body;
} ast_while_clause_t;


/*
 * public interface declarations.
 */
ast_node_t* create_ast_node(ast_type_t type);
void traverse_ast(ast_node_t* node);
const char* node_type_to_str(ast_type_t type);
size_t get_node_size(ast_type_t type);

#endif /* _AST_H_ */
