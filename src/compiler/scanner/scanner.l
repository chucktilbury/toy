/**
 * @file ./out/scanner/scanner.l
 *
 * This is generated by parser_template_generator. If you edit this file,
 * don't run the generator in this directory. Run it in a different one and
 * then merge the results using a tool like diff.
 *
 * @date Sat Jul 19 18:26:30 2025
 * @author Chuck Tilbury
 *
 */

%{
/*
 * This file is a template.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "string_buffer.h"
#include "alloc.h"
#include "errors.h"
#include "fileio.h"
#include "tokens.h"
#include "file_io.h"

int inline_depth = 0;
string_t* strbuf = NULL;
int yycolno = 1;
int prev_lineno;

#define MAX_INCL 16

#define YY_USER_ACTION update_numbers();

%}

%x INLINE_BLOCK DTEXT_BLOCK STEXT_BLOCK DQUOTE SQUOTE

%option yylineno
%option noinput
%option nounput
%option noyywrap

%%
   // int start_line, start_column;
   prev_lineno = yylineno;

"!"	{
    add_token_queue(create_token(create_string(yytext), TOK_BANG));
    return TOK_BANG;
}

"!="	{
    add_token_queue(create_token(create_string(yytext), TOK_BANG_EQUAL));
    return TOK_BANG_EQUAL;
}

"%"	{
    add_token_queue(create_token(create_string(yytext), TOK_PERCENT));
    return TOK_PERCENT;
}

"&"	{
    add_token_queue(create_token(create_string(yytext), TOK_AMP));
    return TOK_AMP;
}

"("	{
    add_token_queue(create_token(create_string(yytext), TOK_OPAREN));
    return TOK_OPAREN;
}

")"	{
    add_token_queue(create_token(create_string(yytext), TOK_CPAREN));
    return TOK_CPAREN;
}

"*"	{
    add_token_queue(create_token(create_string(yytext), TOK_STAR));
    return TOK_STAR;
}

"+"	{
    add_token_queue(create_token(create_string(yytext), TOK_PLUS));
    return TOK_PLUS;
}

","	{
    add_token_queue(create_token(create_string(yytext), TOK_COMMA));
    return TOK_COMMA;
}

"-"	{
    add_token_queue(create_token(create_string(yytext), TOK_MINUS));
    return TOK_MINUS;
}

"."	{
    add_token_queue(create_token(create_string(yytext), TOK_DOT));
    return TOK_DOT;
}

"/"	{
    add_token_queue(create_token(create_string(yytext), TOK_SLASH));
    return TOK_SLASH;
}

":"	{
    add_token_queue(create_token(create_string(yytext), TOK_COLON));
    return TOK_COLON;
}

"<"	{
    add_token_queue(create_token(create_string(yytext), TOK_OPBRACE));
    return TOK_OPBRACE;
}

"<="	{
    add_token_queue(create_token(create_string(yytext), TOK_OPBRACE_EQUAL));
    return TOK_OPBRACE_EQUAL;
}

"="	{
    add_token_queue(create_token(create_string(yytext), TOK_EQUAL));
    return TOK_EQUAL;
}

"=="	{
    add_token_queue(create_token(create_string(yytext), TOK_EQUAL_EQUAL));
    return TOK_EQUAL_EQUAL;
}

">"	{
    add_token_queue(create_token(create_string(yytext), TOK_CPBRACE));
    return TOK_CPBRACE;
}

">="	{
    add_token_queue(create_token(create_string(yytext), TOK_CPBRACE_EQUAL));
    return TOK_CPBRACE_EQUAL;
}

"["	{
    add_token_queue(create_token(create_string(yytext), TOK_OSBRACE));
    return TOK_OSBRACE;
}

"]"	{
    add_token_queue(create_token(create_string(yytext), TOK_CSBRACE));
    return TOK_CSBRACE;
}

"^"	{
    add_token_queue(create_token(create_string(yytext), TOK_CARET));
    return TOK_CARET;
}

"and"	{
    add_token_queue(create_token(create_string(yytext), TOK_AND));
    return TOK_AND;
}

"bool"	{
    add_token_queue(create_token(create_string(yytext), TOK_BOOL));
    return TOK_BOOL;
}

"const"	{
    add_token_queue(create_token(create_string(yytext), TOK_CONST));
    return TOK_CONST;
}

"dict"	{
    add_token_queue(create_token(create_string(yytext), TOK_DICT));
    return TOK_DICT;
}

"do"	{
    add_token_queue(create_token(create_string(yytext), TOK_DO));
    return TOK_DO;
}

"else"	{
    add_token_queue(create_token(create_string(yytext), TOK_ELSE));
    return TOK_ELSE;
}

"equ"	{
    add_token_queue(create_token(create_string(yytext), TOK_EQU));
    return TOK_EQU;
}

"exit"	{
    add_token_queue(create_token(create_string(yytext), TOK_EXIT));
    return TOK_EXIT;
}

"false"	{
    add_token_queue(create_token(create_string(yytext), TOK_FALSE));
    return TOK_FALSE;
}

"float"	{
    add_token_queue(create_token(create_string(yytext), TOK_FLOAT));
    return TOK_FLOAT;
}

"for"	{
    add_token_queue(create_token(create_string(yytext), TOK_FOR));
    return TOK_FOR;
}

"gt"	{
    add_token_queue(create_token(create_string(yytext), TOK_GT));
    return TOK_GT;
}

"gte"	{
    add_token_queue(create_token(create_string(yytext), TOK_GTE));
    return TOK_GTE;
}

"if"	{
    add_token_queue(create_token(create_string(yytext), TOK_IF));
    return TOK_IF;
}

"import"	{
    add_token_queue(create_token(create_string(yytext), TOK_IMPORT));
    return TOK_IMPORT;
}

"in"	{
    add_token_queue(create_token(create_string(yytext), TOK_IN));
    return TOK_IN;
}

"int"	{
    add_token_queue(create_token(create_string(yytext), TOK_INT));
    return TOK_INT;
}

"list"	{
    add_token_queue(create_token(create_string(yytext), TOK_LIST));
    return TOK_LIST;
}

"lt"	{
    add_token_queue(create_token(create_string(yytext), TOK_LT));
    return TOK_LT;
}

"lte"	{
    add_token_queue(create_token(create_string(yytext), TOK_LTE));
    return TOK_LTE;
}

"nequ"	{
    add_token_queue(create_token(create_string(yytext), TOK_NEQU));
    return TOK_NEQU;
}

"not"	{
    add_token_queue(create_token(create_string(yytext), TOK_NOT));
    return TOK_NOT;
}

"nothing"	{
    add_token_queue(create_token(create_string(yytext), TOK_NOTHING));
    return TOK_NOTHING;
}

"or"	{
    add_token_queue(create_token(create_string(yytext), TOK_OR));
    return TOK_OR;
}

"return"	{
    add_token_queue(create_token(create_string(yytext), TOK_RETURN));
    return TOK_RETURN;
}

"start"	{
    add_token_queue(create_token(create_string(yytext), TOK_START));
    return TOK_START;
}

"string"	{
    add_token_queue(create_token(create_string(yytext), TOK_STRING));
    return TOK_STRING;
}

"struct"	{
    add_token_queue(create_token(create_string(yytext), TOK_STRUCT));
    return TOK_STRUCT;
}

"true"	{
    add_token_queue(create_token(create_string(yytext), TOK_TRUE));
    return TOK_TRUE;
}

"while"	{
    add_token_queue(create_token(create_string(yytext), TOK_WHILE));
    return TOK_WHILE;
}

"{"	{
    add_token_queue(create_token(create_string(yytext), TOK_OCBRACE));
    return TOK_OCBRACE;
}

"|"	{
    add_token_queue(create_token(create_string(yytext), TOK_BAR));
    return TOK_BAR;
}

"}"	{
    add_token_queue(create_token(create_string(yytext), TOK_CCBRACE));
    return TOK_CCBRACE;
}



    /* rules defined in the template. */

"inline"[ \n\r\t]*"{" {
    inline_depth = 0;
    if(strbuf == NULL)
        strbuf = create_string(NULL);
    BEGIN(INLINE_BLOCK);
}

<INLINE_BLOCK>"{" {
    inline_depth++;
    append_string_char(strbuf, '{');
}

<INLINE_BLOCK>[^{}\n] {
    append_string(strbuf, yytext);
}

<INLINE_BLOCK>\n {
    append_string_char(strbuf, '\n');
}

<INLINE_BLOCK>"}" {
    if(inline_depth > 0) {
        inline_depth--;
        append_string_char(strbuf, '}');
    }
    else {
        add_token_queue(create_token(copy_string(strbuf), TOK_INLINE));
        clear_string(strbuf);
        BEGIN(INITIAL);
        return TOK_INLINE;
    }
}

\" {
    if(strbuf == NULL)
        strbuf = create_string(NULL);
    BEGIN(DQUOTE);
}

<DQUOTE>\n {
    fprintf(stderr, "scanner error: %d: unexpected end of line in literal string\n", yylineno);
    BEGIN(INITIAL);
}

<DQUOTE>\\n { append_string_char(strbuf, '\n'); }
<DQUOTE>\\r { append_string_char(strbuf, '\r'); }
<DQUOTE>\\t { append_string_char(strbuf, '\t'); }
<DQUOTE>\\v { append_string_char(strbuf, '\v'); }
<DQUOTE>\\a { append_string_char(strbuf, '\a'); }
<DQUOTE>\\b { append_string_char(strbuf, '\b'); }
<DQUOTE>\\f { append_string_char(strbuf, '\f'); }
<DQUOTE>\\e { append_string_char(strbuf, '\x1b'); }
<DQUOTE>\\\" { append_string_char(strbuf, '\"'); }
<DQUOTE>\\. { append_string_char(strbuf, yytext[1]); }

<DQUOTE>\\[xX][0-9A-Fa-f]{1,4} {
    int tmp = strtol(&yytext[2], NULL, 16);
    append_string_char(strbuf, tmp);
}

<DQUOTE>\"[ \t]*\\[ \t]*\n[ \t]*\" { /* line ignore continuation */ }

<DQUOTE>[^\\\n\"]+ { append_string(strbuf, yytext); }

<DQUOTE>\" {
    add_token_queue(create_token(copy_string(strbuf), TOK_STRING_LITERAL));
    clear_string(strbuf);
    BEGIN(INITIAL);
    return TOK_STRING_LITERAL;
}

\' {
    if(strbuf == NULL)
        strbuf = create_string(NULL);
    BEGIN(SQUOTE);
}

<SQUOTE>\'[ \t]*\\[ \t]*\n[ \t]*\' { /* ignore continuation */ }

<SQUOTE>\n {
    fprintf(stderr, "scanner error: %d: unexpected end of line in literal string\n", yylineno);
    BEGIN(INITIAL);
}

<SQUOTE>\\ { append_string_char(strbuf, '\\'); }

<SQUOTE>[^\\\n\']+ { append_string(strbuf, yytext); }

<SQUOTE>\' {
    add_token_queue(create_token(copy_string(strbuf), TOK_STRING_LITERAL));
    clear_string(strbuf);
    BEGIN(INITIAL);
    return TOK_STRING_LITERAL;
}

\"{3,} {
    if(strbuf == NULL)
        strbuf = create_string(NULL);
    BEGIN(DTEXT_BLOCK);
}

<DTEXT_BLOCK>\"  { append_string_char(strbuf, '\"'); }
<DTEXT_BLOCK>(\\n|\n) { append_string_char(strbuf, '\n'); }
<DTEXT_BLOCK>\\r { append_string_char(strbuf, '\r'); }
<DTEXT_BLOCK>\\t { append_string_char(strbuf, '\t'); }
<DTEXT_BLOCK>\\v { append_string_char(strbuf, '\v'); }
<DTEXT_BLOCK>\\a { append_string_char(strbuf, '\a'); }
<DTEXT_BLOCK>\\b { append_string_char(strbuf, '\b'); }
<DTEXT_BLOCK>\\f { append_string_char(strbuf, '\f'); }
<DTEXT_BLOCK>\\e { append_string_char(strbuf, '\x1b'); }
<DTEXT_BLOCK>\\. { append_string_char(strbuf, yytext[1]); }

<DTEXT_BLOCK>\\[xX][0-9a-fA-F]{1,4} {
    int tmp = strtol(&yytext[2], NULL, 16);
    append_string_char(strbuf, tmp);
}

<DTEXT_BLOCK>[^\"\n\\]+ { append_string(strbuf, yytext); }

<DTEXT_BLOCK>\"{3,} {
    add_token_queue(create_token(copy_string(strbuf), TOK_STRING_LITERAL));
    clear_string(strbuf);
    BEGIN(INITIAL);
    return TOK_STRING_LITERAL;
}

\'{3,} {
    if(strbuf == NULL)
        strbuf = create_string(NULL);
    BEGIN(STEXT_BLOCK);
}

<STEXT_BLOCK>\' { append_string_char(strbuf, '\''); }
<STEXT_BLOCK>\n { append_string_char(strbuf, ' '); }
<STEXT_BLOCK>\\. { append_string_char(strbuf, yytext[1]); }
<STEXT_BLOCK>[^\'\n]+ { append_string(strbuf, yytext); }

<STEXT_BLOCK>\'{3,} {
    add_token_queue(create_token(copy_string(strbuf), TOK_STRING_LITERAL));
    clear_string(strbuf);
    BEGIN(INITIAL);
    return TOK_STRING_LITERAL;
}

[a-zA-Z_][0-9a-zA-Z_]*  {
    add_token_queue(create_token(create_string(yytext), TOK_IDENTIFIER));
    return TOK_IDENTIFIER;
}

(([1-9][0-9]*\.[0-9]+)|(0\.[0-9]+))([eE][-+]?[0-9]+)? {
    add_token_queue(create_token(create_string(yytext), TOK_FLOAT_LITERAL));
    return TOK_FLOAT_LITERAL;
}

([1-9][0-9]*)|0 {
    add_token_queue(create_token(create_string(yytext), TOK_INT_LITERAL));
    return TOK_INT_LITERAL;
}

(";"|"#")[^\n]*\n  { /* ignore comment */ }

[ \t\r\n\v\f]+ { /* ignore spaces */ }

. { fprintf(stderr, "scanner error: %d: unexpected character: %c (0x%02X)\n", yylineno, yytext[0], yytext[0]); }

<<EOF>> {
    add_token_queue(create_token(create_string(NULL), TOK_END_OF_FILE));
    yyterminate(); // return NULL
}

%%



