/**
 * @file ./out/parser/expression.c
 *
 * This is generated by parser_template_generator. If you edit this file,
 * don't run the generator in this directory. Run it in a different one and
 * then merge the results using a tool like diff.
 *
 * @date Sat Jul 19 18:26:30 2025
 * @author Chuck Tilbury
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include "trace.h"
#include "errors.h"
#include "parser_protos.h"

/*
 * expression (
 *     expression TOK_STAR expression |
 *     expression TOK_SLASH expression |
 *     expression TOK_PERCENT expression |
 *     expression TOK_PLUS expression |
 *     expression TOK_MINUS expression |
 *     expression ( TOK_CPBRACE | TOK_GT ) expression |
 *     expression ( TOK_OPBRACE | TOK_LT ) expression |
 *     expression ( TOK_CPBRACE_EQUAL | TOK_GTE ) expression |
 *     expression ( TOK_OPBRACE_EQUAL | TOK_LTE ) expression |
 *     expression ( TOK_EQUAL_EQUAL | TOK_EQU ) expression |
 *     expression ( TOK_BANG_EQUAL | TOK_NEQU ) expression |
 *     expression ( TOK_AMP | TOK_AND ) expression |
 *     expression ( TOK_BAR | TOK_OR ) expression |
 *     expression TOK_CARET expression |
 *     ( TOK_BANG | TOK_NOT ) expression |
 *     TOK_MINUS expression |
 *     primary_expression
 * )
 *
 *
 * begin grouping_function (1000)
 *   non-terminal rule element: expression
 *   terminal rule element: TOK_STAR
 *   begin or_function (1100)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1100)
 *   terminal rule element: TOK_SLASH
 *   begin or_function (1200)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1200)
 *   terminal rule element: TOK_PERCENT
 *   begin or_function (1300)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1300)
 *   terminal rule element: TOK_PLUS
 *   begin or_function (1400)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1400)
 *   terminal rule element: TOK_MINUS
 *   begin or_function (1500)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1500)
 *   begin grouping_function (1600)
 *     begin or_function (1700)
 *       terminal rule element: TOK_CPBRACE
 *       terminal rule element: TOK_GT
 *     end or_function (1700)
 *   end grouping_function (1600)
 *   begin or_function (1800)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (1800)
 *   begin grouping_function (1900)
 *     begin or_function (2000)
 *       terminal rule element: TOK_OPBRACE
 *       terminal rule element: TOK_LT
 *     end or_function (2000)
 *   end grouping_function (1900)
 *   begin or_function (2100)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (2100)
 *   begin grouping_function (2200)
 *     begin or_function (2300)
 *       terminal rule element: TOK_CPBRACE_EQUAL
 *       terminal rule element: TOK_GTE
 *     end or_function (2300)
 *   end grouping_function (2200)
 *   begin or_function (2400)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (2400)
 *   begin grouping_function (2500)
 *     begin or_function (2600)
 *       terminal rule element: TOK_OPBRACE_EQUAL
 *       terminal rule element: TOK_LTE
 *     end or_function (2600)
 *   end grouping_function (2500)
 *   begin or_function (2700)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (2700)
 *   begin grouping_function (2800)
 *     begin or_function (2900)
 *       terminal rule element: TOK_EQUAL_EQUAL
 *       terminal rule element: TOK_EQU
 *     end or_function (2900)
 *   end grouping_function (2800)
 *   begin or_function (3000)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (3000)
 *   begin grouping_function (3100)
 *     begin or_function (3200)
 *       terminal rule element: TOK_BANG_EQUAL
 *       terminal rule element: TOK_NEQU
 *     end or_function (3200)
 *   end grouping_function (3100)
 *   begin or_function (3300)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (3300)
 *   begin grouping_function (3400)
 *     begin or_function (3500)
 *       terminal rule element: TOK_AMP
 *       terminal rule element: TOK_AND
 *     end or_function (3500)
 *   end grouping_function (3400)
 *   begin or_function (3600)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (3600)
 *   begin grouping_function (3700)
 *     begin or_function (3800)
 *       terminal rule element: TOK_BAR
 *       terminal rule element: TOK_OR
 *     end or_function (3800)
 *   end grouping_function (3700)
 *   begin or_function (3900)
 *     non-terminal rule element: expression
 *     non-terminal rule element: expression
 *   end or_function (3900)
 *   terminal rule element: TOK_CARET
 *   begin or_function (4000)
 *     non-terminal rule element: expression
 *     begin grouping_function (4100)
 *       begin or_function (4200)
 *         terminal rule element: TOK_BANG
 *         terminal rule element: TOK_NOT
 *       end or_function (4200)
 *     end grouping_function (4100)
 *   end or_function (4000)
 *   begin or_function (4300)
 *     non-terminal rule element: expression
 *     terminal rule element: TOK_MINUS
 *   end or_function (4300)
 *   begin or_function (4400)
 *     non-terminal rule element: expression
 *     non-terminal rule element: primary_expression
 *   end or_function (4400)
 * end grouping_function (1000)
 *
 */
ast_expression_t* parse_expression(parser_state_t* pstate) {

    ENTER;
    ASSERT(pstate != NULL, "null pstate is not allowed");
    ast_expression_t* retv = NULL;
    int state = 1000;
    bool finished = false;
    void* post = mark_token_queue();

    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // token_t* TERMINAL_OPER = NULL;
    // ast_expression_t* expression = NULL;
    // ast_primary_expression_t* primary_expression = NULL;


    while(!finished) {
        switch(state) {

            // begin or_function rule at state 1100:1
            case 1100:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1100

            // begin or_function rule at state 1200:1
            case 1200:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1200

            // begin or_function rule at state 1300:1
            case 1300:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1300

            // begin or_function rule at state 1400:1
            case 1400:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1400

            // begin or_function rule at state 1500:1
            case 1500:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1500

            // begin or_function rule at state 1700:2
            case 1700:
                // terminal rule element: TOK_CPBRACE
                // terminal rule element: TOK_GT
                break;
            // end or_function rule at state 1700

            // begin grouping_function rule at state 1600:1
            case 1600:
                break;
            // end grouping_function rule at state 1600

            // begin or_function rule at state 1800:1
            case 1800:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 1800

            // begin or_function rule at state 2000:2
            case 2000:
                // terminal rule element: TOK_OPBRACE
                // terminal rule element: TOK_LT
                break;
            // end or_function rule at state 2000

            // begin grouping_function rule at state 1900:1
            case 1900:
                break;
            // end grouping_function rule at state 1900

            // begin or_function rule at state 2100:1
            case 2100:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 2100

            // begin or_function rule at state 2300:2
            case 2300:
                // terminal rule element: TOK_CPBRACE_EQUAL
                // terminal rule element: TOK_GTE
                break;
            // end or_function rule at state 2300

            // begin grouping_function rule at state 2200:1
            case 2200:
                break;
            // end grouping_function rule at state 2200

            // begin or_function rule at state 2400:1
            case 2400:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 2400

            // begin or_function rule at state 2600:2
            case 2600:
                // terminal rule element: TOK_OPBRACE_EQUAL
                // terminal rule element: TOK_LTE
                break;
            // end or_function rule at state 2600

            // begin grouping_function rule at state 2500:1
            case 2500:
                break;
            // end grouping_function rule at state 2500

            // begin or_function rule at state 2700:1
            case 2700:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 2700

            // begin or_function rule at state 2900:2
            case 2900:
                // terminal rule element: TOK_EQUAL_EQUAL
                // terminal rule element: TOK_EQU
                break;
            // end or_function rule at state 2900

            // begin grouping_function rule at state 2800:1
            case 2800:
                break;
            // end grouping_function rule at state 2800

            // begin or_function rule at state 3000:1
            case 3000:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 3000

            // begin or_function rule at state 3200:2
            case 3200:
                // terminal rule element: TOK_BANG_EQUAL
                // terminal rule element: TOK_NEQU
                break;
            // end or_function rule at state 3200

            // begin grouping_function rule at state 3100:1
            case 3100:
                break;
            // end grouping_function rule at state 3100

            // begin or_function rule at state 3300:1
            case 3300:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 3300

            // begin or_function rule at state 3500:2
            case 3500:
                // terminal rule element: TOK_AMP
                // terminal rule element: TOK_AND
                break;
            // end or_function rule at state 3500

            // begin grouping_function rule at state 3400:1
            case 3400:
                break;
            // end grouping_function rule at state 3400

            // begin or_function rule at state 3600:1
            case 3600:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 3600

            // begin or_function rule at state 3800:2
            case 3800:
                // terminal rule element: TOK_BAR
                // terminal rule element: TOK_OR
                break;
            // end or_function rule at state 3800

            // begin grouping_function rule at state 3700:1
            case 3700:
                break;
            // end grouping_function rule at state 3700

            // begin or_function rule at state 3900:1
            case 3900:
                // non-terminal rule element: expression
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 3900

            // begin or_function rule at state 4200:3
            case 4200:
                // terminal rule element: TOK_BANG
                // terminal rule element: TOK_NOT
                break;
            // end or_function rule at state 4200

            // begin grouping_function rule at state 4100:2
            case 4100:
                break;
            // end grouping_function rule at state 4100

            // begin or_function rule at state 4000:1
            case 4000:
                // non-terminal rule element: expression
                break;
            // end or_function rule at state 4000

            // begin or_function rule at state 4300:1
            case 4300:
                // non-terminal rule element: expression
                // terminal rule element: TOK_MINUS
                break;
            // end or_function rule at state 4300

            // begin or_function rule at state 4400:1
            case 4400:
                // non-terminal rule element: expression
                // non-terminal rule element: primary_expression
                break;
            // end or_function rule at state 4400

            // begin grouping_function rule at state 1000:0
            case 1000:
                // non-terminal rule element: expression
                // terminal rule element: TOK_STAR
                // terminal rule element: TOK_SLASH
                // terminal rule element: TOK_PERCENT
                // terminal rule element: TOK_PLUS
                // terminal rule element: TOK_MINUS
                // terminal rule element: TOK_CARET
                break;
                // end grouping_function rule at state 1000


            case STATE_MATCH:
                TRACE_STATE;
                consume_token_queue();
                retv = (ast_expression_t*)create_ast_node(AST_EXPRESSION);
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->TERMINAL_OPER = TERMINAL_OPER;
                // retv->expression = expression;
                // retv->primary_expression = primary_expression;

                break;
            case STATE_NO_MATCH:
                TRACE_STATE;
                restore_token_queue(post);
                finished = true;
                break;
            case STATE_ERROR:
                TRACE_STATE;
                restore_token_queue(post);
                recover_parser_error(pstate);
                finished = true;
                break;
            default:
                FATAL("unknown state: %d", state);
        }
    }

    RETURN(retv);
}
